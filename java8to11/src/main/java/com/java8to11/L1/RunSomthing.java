package com.java8to11.L1;

@FunctionalInterface // 자바가 제공해주는 어노테이션임 - 함수형 인터페이스를 좀 더 견고하게 사용하기 위해 사용
public interface RunSomthing {
	/*
	 * 함수형 인터페이스와 람다 표현식1
	 * 
	 * 함수형 인터페이스(FuncationInterface)
	 * 	- 추상 메소드를 딱 하나만 가지고 있는 인터페이스
	 * 	- SAM (Single Abstract Method) 인터페이스
	 * 	- @FuncationInterface 어노테이션을 가지고 있는 인터페이스
	 * 
	 * 람다 표현식(Lambda Expressions)
	 * 	- 함수형 인퍼테이스의 인스턴스를 만드는 방법으로 쓰일 수 있다.
	 * 	- 코드를 줄일 수 있다.
	 *  - 메소드 매개변수, 리턴 타입, 변수로 만들어 사용할 수 있다.
	 *  
	 * 자바에서 함수형 프로그래밍
	 *  - 함수를 First class object로 사용할 수 있다.
	 *  순수 함수(Pure function)
	 *  - 사이드 이팩트 만들 수 없다.(함수 밖에 있는 값을 변경하지 못한다.)
	 *  - 상태가 없다.(함수 밖에 정의되어 있는)
	 *  고차함수(High-Order Function)
	 *  - 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수도 있다.
	 *  불변성
	 */
	
	/* 생각나는대로 정리하기
	 *  메소드? 
	 *  1.어떤 특정 작업을 수행하기 위한 명령문의 집합 - 기능 표현
	 */
	
	/*
	   	메소드를 사용하는 이유?
	  	1.중복되는 코드의 반복적인 프로그래밍을 피하기 위해 
 		2.코드가 메소드가 되어 모듈화 -> 가독성 좋아짐
 		3.손쉬운 유지보수 가능
	 */
	
	/*
	 	그럼 추상 메소드는 무엇인가? 
	 	1. 선언부만 작성하고 구현부는 작성하지 않은채로 남겨둔 것
		
		선언부?, 구현부?, 실재 내용은?
		1. 선언부 - 접근제어자 반환타입 메소드이름(매개변수들) { 로 이루어짐
		2. 구현부 - 메소드의 고유 기능을 수행하는 명령문의 집합 - {}에 들어감
		3. 구현부 실재 내용 - 상속 받는 클래스에서 구현하도록 비워둔 것
	 */
	
	/*
	 	추상메소드 하나만 있으면 함수형 인터페이스! 
	 	- 다른 메소드가 있고 추상 메소드가 딱 하나만있으면 함수형 인터페이스
		아래에서는 abstract를 사용하지 않았음 왜? 인터페이스에서는 원래 생략가능
 		그럼 추상메소드가 두개가 있는경우? 안됨!
	 */
	//순수 함수 테스트를 위해 리턴값 int 형태로 변경, 파라미터 int 추가 
	//원래는 void doIt();
	int doIt(int number);
	
	// 자바8 새로운 기능 - 인터페이스에서 정의할 수 있는 메소드 형태가 다양해짐
	// public, static 생략 가능!!
	static void printName() {
		System.out.println("youngho");
	}
	// 디폴트 메소드를 정의 가능 
	default void printAge() {
		System.out.println("30");
	}
}
